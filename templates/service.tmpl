package service

import (
	"context"
	"database/sql"
	"errors"
	"math"
	"strings"
	"time"
	
	".../{{.PackageName}}"
	".../{{.PackageName}}/api"
	"google.golang.org/protobuf/types/known/emptypb"

)
{{ $pkgName := .PackageName}}
{{ $tableName := .GoTableName}}

// {{.GoTableName}}ServiceImpl {{.GoTableName}}ServiceImpl
type {{.GoTableName}}ServiceImpl struct {
	db *sql.DB
}

// Create{{.GoTableName}} Create{{.GoTableName}}
func (s *{{.GoTableName}}ServiceImpl) CreateUser(ctx context.Context, req *api.{{.GoTableName}}) (*api.{{.GoTableName}}, error) {
	
	// do some parameter check
	// if req.GetXXXX() != 0 {
	// 	return nil, errors.New(-1, "参数错误")
	// }
	a := &{{.PackageName}}.{{.GoTableName}}{
		{{- range $index,$field := .Fields }}
			{{- if ne .GoColumnType  "time.Time"}}
				{{- if eq $field.IsAutoIncrment true}}
					{{$field.GoColumnName}}:0,
				{{- else }}
    				{{$field.GoColumnName}}:req.Get{{$field.GoColumnName}}(),
				{{- end}}
			{{- else}}
				{{- if eq .IsDefaultCurrentTimestamp true}}	
					{{$field.GoColumnName}}:time.Now(),
				{{- end}}
			{{- end}}  
		{{- end}}  
	}
	var err error
	{{- range $index,$field := .Fields }}
			{{- if eq .GoColumnType  "time.Time"}}
				{{- if eq .IsDefaultCurrentTimestamp false}}
					{{- if eq $field.DataType "date"}}
						if a.{{$field.GoColumnName}}, err = time.ParseInLocation("2006-01-02", req.Get{{$field.GoColumnName}}(), time.Local); err != nil {
							return nil, err
						}
					{{- else }}
						if a.{{$field.GoColumnName}}, err = time.ParseInLocation("2006-01-02 15:04:05", req.Get{{$field.GoColumnName}}(), time.Local); err != nil {
							return nil, err
						}
					{{- end}}
				{{- end}}
			{{- end}}  
	{{- end}}  
	_, err = {{.PackageName}}.Create(s.db).Set{{.GoTableName}}(a).Save(ctx)
	if err != nil {
		return nil, err
	}
	// query after create and return
	a2, err := {{.PackageName}}.Find(s.db).Where({{.PackageName}}.{{.PrimaryKey.GoColumnName}}EQ(a.{{.PrimaryKey.GoColumnName}})).One(ctx)
	if err != nil {
		return nil, err
	}
	return convert{{.GoTableName}}(a2), nil
}

// Delete{{.GoTableName}} Delete{{.GoTableName}}
func (s *{{.GoTableName}}ServiceImpl) Deletes{{.GoTableName}}(ctx context.Context, req *api.{{.GoTableName}}{{.PrimaryKey.GoColumnName}}) (*emptypb.Empty, error) {
	_, err := {{.PackageName}}.Delete(s.db).Where({{.PackageName}}.{{.PrimaryKey.GoColumnName}}EQ(req.Get{{.PrimaryKey.GoColumnName}}())).Exec(ctx)
	if err != nil {
		return nil, err
	}
	return &emptypb.Empty{}, nil
}

// Update{{.PackageName}} Update{{.GoTableName}}
func (s *{{.GoTableName}}ServiceImpl) Update{{.GoTableName}}(ctx context.Context, req *api.Update{{.GoTableName}}Req) (*api.{{.GoTableName}}, error) {

	if len(req.GetUpdateMask()) == 0 {
		return nil, errors.New("update_mask empty")
	}
	update := {{.PackageName}}.Update(s.db)
	for _, v := range req.GetUpdateMask() {
		switch v {	
		{{- range $index,$field := .Fields }}
		
			{{- if eq $field.IsPrimaryKey false}}
				case "{{$pkgName}}.{{$field.ColumnName}}":
				{{- if eq .GoColumnType  "time.Time"}}
					{{- if eq $field.DataType "date" }}
						t, err := time.ParseInLocation("2006-01-02", req.Get{{$tableName}}().Get{{$field.GoColumnName}}(), time.Local)
						if err != nil {
							return nil, err
						}
						update.Set{{$field.GoColumnName}}(t)
					{{- else }}
						t, err := time.ParseInLocation("2006-01-02 15:04:05", req.Get{{$tableName}}().Get{{$field.GoColumnName}}(), time.Local)
						if err != nil {
							return nil, err
						}
						update.Set{{$field.GoColumnName}}(t)
					{{- end }}
				{{- else}}
				update.Set{{$field.GoColumnName}}(req.Get{{$tableName}}().Get{{$field.GoColumnName}}())	
				{{- end}}
			
			{{- end}}
		{{- end}}  
		}
	}
	_, err := update.Where({{.PackageName}}.{{.PrimaryKey.GoColumnName}}EQ(req.Get{{.GoTableName}}().Get{{.PrimaryKey.GoColumnName}}())).Save(ctx)
	if err != nil {
		return nil, err
	}
	// query after update and return
	a, err := {{.PackageName}}.Find(s.db).Where({{.PackageName}}.{{.PrimaryKey.GoColumnName}}EQ(req.Get{{.GoTableName}}().Get{{.PrimaryKey.GoColumnName}}())).One(ctx)
	if err != nil {
		return nil, err
	}
	return convert{{.GoTableName}}(a), nil
}

// Get{{.GoTableName}} Get{{.GoTableName}}
func (s *{{.GoTableName}}ServiceImpl) Get{{.GoTableName}}(ctx context.Context, req *api.{{.GoTableName}}{{.PrimaryKey.GoColumnName}}) (*api.{{.GoTableName}}, error) {
	a, err := {{.PackageName}}.Find(s.db).Where({{.PackageName}}.{{.PrimaryKey.GoColumnName}}EQ(req.Get{{.PrimaryKey.GoColumnName}}())).One(ctx)
	if err != nil {
		return nil, err
	}
	return convert{{.GoTableName}}(a), nil
}

// List{{.GoTableName}}s List{{.GoTableName}}s
func (s *{{.GoTableName}}ServiceImpl) List{{.GoTableName}}s(ctx context.Context, req *api.List{{.GoTableName}}sReq) (*api.List{{.GoTableName}}sResp, error) {
	page := req.GetPage()
	size := req.GetPageSize()
	if size <= 0 {
		size = 20
	}
	offset := size * (page - 1)
	if offset < 0 {
		offset = 0
	}
	find := {{.PackageName}}.Find(s.db).Offset(offset).Limit(size)
	for _, v := range req.GetOrderby() {
		if strings.HasPrefix(v, "-") {
			find.OrderDesc(strings.TrimPrefix(v, "-"))
			continue
		}
		find.OrderAsc(v)
	}
	// costom filter
	// {
	// 	find.Where({{.PackageName}}.NameContains(req.GetFilter()))
	// }
	list, err := find.All(ctx)
	if err != nil {
		return nil, err
	}
	count, err := {{.PackageName}}.Find(s.db).Count().Int64(ctx)
	if err != nil {
		return nil, err
	}
	pageCount := int64(math.Ceil(float64(count) / float64(size)))

	return &api.List{{.GoTableName}}sResp{ {{.GoTableName}}s: convert{{.GoTableName}}List(list), TotalCount: count, PageCount: pageCount}, nil
}

func convert{{.GoTableName}}(a *{{.PackageName}}.{{.GoTableName}}) *api.{{.GoTableName}} {
	return &api.{{.GoTableName}}{
		{{- range $index,$field := .Fields }}
		{{- if eq .GoColumnType  "time.Time"}}
			{{- if eq .DataType "date"}}
			{{$field.GoColumnName}}:a.{{$field.GoColumnName}}.Format("2006-01-02"),
			{{- else}}
			{{$field.GoColumnName}}:a.{{$field.GoColumnName}}.Format("2006-01-02 15:04:05"),
			{{- end}} 
		{{- else}}
			{{$field.GoColumnName}}:a.{{$field.GoColumnName}},
		{{- end}}	
		{{- end}}  
	}
}

func convert{{.GoTableName}}List(list []*{{.PackageName}}.{{.GoTableName}}) []*api.{{.GoTableName}} {
	ret := make([]*api.{{.GoTableName}}, 0, len(list))
	for _, v := range list {
		ret = append(ret, convert{{.GoTableName}}(v))
	}
	return ret
}
